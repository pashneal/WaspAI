!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	//
BitboardContainer	Bitboard.cpp	/^BitboardContainer::BitboardContainer(unordered_map<int, unsigned long long > predefinedBoards){$/;"	f	class:BitboardContainer
Hive	Hive.cpp	/^Hive::Hive() { $/;"	f	class:Hive
Piece	Piece.cpp	/^Piece::Piece(char pieceColor, string shorthand, int xPos, int yPos) {$/;"	f	class:Piece
PieceNode	PieceNode.cpp	/^PieceNode::PieceNode(int pieceNum, BitboardContainer b) { $/;"	f	class:PieceNode
adjustOverflowMask	Bitboard.cpp	/^unsigned long long BitboardContainer::adjustOverflowMask($/;"	f	class:BitboardContainer	typeref:typename:unsigned long long
clear	Bitboard.cpp	/^void BitboardContainer::clear() {$/;"	f	class:BitboardContainer	typeref:typename:void
containsAny	Bitboard.cpp	/^bool BitboardContainer::containsAny(BitboardContainer& other) {$/;"	f	class:BitboardContainer	typeref:typename:bool
convertToHexRepresentation	Bitboard.cpp	/^void BitboardContainer::convertToHexRepresentation ($/;"	f	class:BitboardContainer	typeref:typename:void
createLowOverflowMask	Bitboard.cpp	/^unsigned long long BitboardContainer::createLowOverflowMask(Direction dir, int overflowAmount) {$/;"	f	class:BitboardContainer	typeref:typename:unsigned long long
directions	Test.cpp	/^ unordered_map < string , vector<Direction> > directions = $/;"	v	typeref:typename:unordered_map<string,vector<Direction>>
duplicateBoard	Bitboard.cpp	/^void BitboardContainer::duplicateBoard(vector <Direction> dirs){$/;"	f	class:BitboardContainer	typeref:typename:void
dxdy	Test.cpp	/^ int dxdy[6][2] = {{1,1},$/;"	v	typeref:typename:int[6][2]
equals	Bitboard.cpp	/^bool BitboardContainer::equals(BitboardContainer& other){$/;"	f	class:BitboardContainer	typeref:typename:bool
findAllProblemNodes	Bitboard.cpp	/^void BitboardContainer::findAllProblemNodes(BitboardContainer &result ){$/;"	f	class:BitboardContainer	typeref:typename:void
findBoundingBoxes	Bitboard.cpp	/^void BitboardContainer::findBoundingBoxes(){$/;"	f	class:BitboardContainer	typeref:typename:void
findBoundingBoxes	Bitboard.cpp	/^void BitboardContainer::findBoundingBoxes(int boardIndex){$/;"	f	class:BitboardContainer	typeref:typename:void
findProblemNodesContainingPiece	Bitboard.cpp	/^void BitboardContainer::findProblemNodesContainingPiece(BitboardContainer &result,$/;"	f	class:BitboardContainer	typeref:typename:void
floodFill	Bitboard.cpp	/^void BitboardContainer::floodFill(BitboardContainer &frontier){$/;"	f	class:BitboardContainer	typeref:typename:void
floodFillStep	Bitboard.cpp	/^void BitboardContainer::floodFillStep(BitboardContainer &frontier,  BitboardContainer &visited){$/;"	f	class:BitboardContainer	typeref:typename:void
gates	Bitboard.cpp	/^BitboardContainer gates[] = {$/;"	v	typeref:typename:BitboardContainer[]
generateAntMoves	MoveGenerator.cpp	/^void MoveGenerator::generateAntMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateBeetleMoves	MoveGenerator.cpp	/^void MoveGenerator::generateBeetleMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateGrasshopperMoves	MoveGenerator.cpp	/^void MoveGenerator::generateGrasshopperMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateLadybugMoves	MoveGenerator.cpp	/^void MoveGenerator::generateLadybugMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateMosquitoMoves	MoveGenerator.cpp	/^void MoveGenerator::generateMosquitoMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateMoves	MoveGenerator.cpp	/^void MoveGenerator::generateMoves() {$/;"	f	class:MoveGenerator	typeref:typename:void
generatePillbugMoves	MoveGenerator.cpp	/^void MoveGenerator::generatePillbugMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generatePillbugSwap	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::generatePillbugSwap() {$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
generateQueenMoves	MoveGenerator.cpp	/^void MoveGenerator::generateQueenMoves(){ $/;"	f	class:MoveGenerator	typeref:typename:void
generateSpiderMoves	MoveGenerator.cpp	/^void MoveGenerator::generateSpiderMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
getArticulationNodes	Hive.cpp	/^void Hive::getArticulationNodes(PieceNode &n, int &counter) {$/;"	f	class:Hive	typeref:typename:void
getInaccessibleNodes	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::getInaccessibleNodes(BitboardContainer gates) {$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
getInaccessibleNodes	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::getInaccessibleNodes(vector <BitboardContainer> * gates) {$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
getMoves	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::getMoves() {	$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
getPerimeter	Bitboard.cpp	/^BitboardContainer  BitboardContainer::getPerimeter() {$/;"	f	class:BitboardContainer	typeref:typename:BitboardContainer
getPiece	Hive.cpp	/^Piece * Hive::getPiece(char color, string shorthandName){$/;"	f	class:Hive	typeref:typename:Piece *
getPiece	Hive.cpp	/^Piece * Hive::getPiece(int pieceNumber) {$/;"	f	class:Hive	typeref:typename:Piece *
getPieceArray	Hive.cpp	/^Piece * Hive::getPieceArray(){$/;"	f	class:Hive	typeref:typename:Piece *
getPieceLookupSet	Hive.cpp	/^set<int> Hive::getPieceLookupSet(){$/;"	f	class:Hive	typeref:typename:set<int>
getPieceLookupTable	Hive.cpp	/^bool * Hive::getPieceLookupTable(){$/;"	f	class:Hive	typeref:typename:bool *
initialize	Bitboard.cpp	/^void BitboardContainer::initialize(unordered_map < int, unsigned long long> predefinedBoards) {$/;"	f	class:BitboardContainer	typeref:typename:void
initializeTo	Bitboard.cpp	/^void BitboardContainer::initializeTo(BitboardContainer &other) {$/;"	f	class:BitboardContainer	typeref:typename:void
insert	PieceNode.cpp	/^void PieceNode::insert( list <PieceNode*> &newNeighbors, BitboardContainer &newBitboard) {$/;"	f	class:PieceNode	typeref:typename:void
insertPiece	Hive.cpp	/^void Hive::insertPiece(Piece piece){$/;"	f	class:Hive	typeref:typename:void
insertPiece	Hive.cpp	/^void Hive::insertPiece(char pieceColor, string shorthandName,$/;"	f	class:Hive	typeref:typename:void
insertPieceTest	Test.cpp	/^void Test::HiveTest::insertPieceTest() {$/;"	f	class:Test::HiveTest	typeref:typename:void
intersectionWith	Bitboard.cpp	/^void BitboardContainer::intersectionWith( BitboardContainer &other) {$/;"	f	class:BitboardContainer	typeref:typename:void
main	Test.cpp	/^int main() {$/;"	f	typeref:typename:int
movePiece	Hive.cpp	/^void Hive::movePiece(char color, string shorthandName, bool right,$/;"	f	class:Hive	typeref:typename:void
movePiece	Hive.cpp	/^void Hive::movePiece(char color, string shorthandName,$/;"	f	class:Hive	typeref:typename:void
movePiece	Hive.cpp	/^void Hive::movePiece(int piece1Int, Direction dir ,int piece2Int){$/;"	f	class:Hive	typeref:typename:void
movePieceTest	Test.cpp	/^void Test::HiveTest::movePieceTest(){$/;"	f	class:Test::HiveTest	typeref:typename:void
numDirections	Bitboard.cpp	/^int numDirections = 6;$/;"	v	typeref:typename:int
overflowBitmask	Bitboard.cpp	/^unordered_map <Direction, unsigned long long> overflowBitmask =$/;"	v	typeref:typename:unordered_map<Direction,unsigned long long>
overflowLocation	Bitboard.cpp	/^unordered_map <Direction, vector<int>> overflowLocation =$/;"	v	typeref:typename:unordered_map<Direction,vector<int>>
parameters	Bitboard.cpp	/^unordered_map <Direction, vector<int>> parameters  = {$/;"	v	typeref:typename:unordered_map<Direction,vector<int>>
parseCommand	Hive.cpp	/^bool Hive::parseCommand(vector<string> command){$/;"	f	class:Hive	typeref:typename:bool
parseCommandTest	Test.cpp	/^void Test::HiveTest::parseCommandTest(){$/;"	f	class:Test::HiveTest	typeref:typename:void
pass	Test.cpp	/^void Test::pass(bool testPassed, string message){$/;"	f	class:Test	typeref:typename:void
pieceInHive	Hive.cpp	/^bool Hive::pieceInHive(char color, string shorthandName) {$/;"	f	class:Hive	typeref:typename:bool
pieceInHive	Hive.cpp	/^bool Hive::pieceInHive(int pieceNum) {$/;"	f	class:Hive	typeref:typename:bool
pieceName	Piece.cpp	/^unordered_map<string , string> pieceName = {{"Q","queen"},$/;"	v	typeref:typename:unordered_map<string,string>
pieceNum	Test.cpp	/^ unordered_map <string, int> pieceNum = {{"Q",0},$/;"	v	typeref:typename:unordered_map<string,int>
pieceNumber	Hive.cpp	/^int Hive::pieceNumber(Piece piece){$/;"	f	class:Hive	typeref:typename:int
pieceNumber	Hive.cpp	/^int Hive::pieceNumber(char color, string shorthandName) {$/;"	f	class:Hive	typeref:typename:int
potentialProblemNodes	Bitboard.cpp	/^BitboardContainer potentialProblemNodes[] = {$/;"	v	typeref:typename:BitboardContainer[]
print	Hive.cpp	/^void Hive::print() {$/;"	f	class:Hive	typeref:typename:void
printDebug	Hive.cpp	/^void Hive::printDebug() {$/;"	f	class:Hive	typeref:typename:void
pruneCache	Bitboard.cpp	/^void BitboardContainer::pruneCache(){$/;"	f	class:BitboardContainer	typeref:typename:void
reposition	PieceNode.cpp	/^void PieceNode::reposition(list <PieceNode*> &newNeighbors, BitboardContainer &newBitboard){$/;"	f	class:PieceNode	typeref:typename:void
setBoard	Bitboard.cpp	/^void BitboardContainer::setBoard(int boardIndex, unsigned long long board) {$/;"	f	class:BitboardContainer	typeref:typename:void
setGatesSplit	MoveGenerator.cpp	/^void MoveGenerator::setGatesSplit( vector <BitboardContainer> * p){$/;"	f	class:MoveGenerator	typeref:typename:void
shiftDirection	Bitboard.cpp	/^void BitboardContainer::shiftDirection(Direction dir) {$/;"	f	class:BitboardContainer	typeref:typename:void
shiftDirection	Bitboard.cpp	/^void BitboardContainer::shiftDirection(Direction dir, int numTimes){$/;"	f	class:BitboardContainer	typeref:typename:void
shiftDirection	PieceNode.cpp	/^void PieceNode::shiftDirection(Direction dir) {$/;"	f	class:PieceNode	typeref:typename:void
shiftDirection	PieceNode.cpp	/^void PieceNode::shiftDirection(Direction dir, int numTimes) {$/;"	f	class:PieceNode	typeref:typename:void
shiftOrthogonalDirection	Bitboard.cpp	/^void BitboardContainer::shiftOrthogonalDirection(Direction dir, int numTimes){$/;"	f	class:BitboardContainer	typeref:typename:void
silent	Test.cpp	/^bool Test::silent = false;$/;"	m	class:Test	typeref:typename:bool
split	Bitboard.cpp	/^unordered_map< int, vector < unsigned long long >> BitboardContainer::split(){$/;"	f	class:BitboardContainer	typeref:typename:unordered_map<int,vector<unsigned long long>>
splitIntoConnectedComponents	Bitboard.cpp	/^vector <BitboardContainer> BitboardContainer::splitIntoConnectedComponents(){$/;"	f	class:BitboardContainer	typeref:typename:vector<BitboardContainer>
testBitboardBoundings	Test.cpp	/^void Test::BitboardTest::testBitboardBoundings(){$/;"	f	class:Test::BitboardTest	typeref:typename:void
testContainsAny	Test.cpp	/^void Test::BitboardTest::testContainsAny() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testFindAllProblemNodes	Test.cpp	/^void Test::BitboardTest::testFindAllProblemNodes(){$/;"	f	class:Test::BitboardTest	typeref:typename:void
testFloodFill	Test.cpp	/^void Test::BitboardTest::testFloodFill() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testFloodFillStep	Test.cpp	/^void Test::BitboardTest::testFloodFillStep() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testIntersectionWith	Test.cpp	/^void Test::BitboardTest::testIntersectionWith() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testShiftDirection	Test.cpp	/^void Test::BitboardTest::testShiftDirection(){$/;"	f	class:Test::BitboardTest	typeref:typename:void
testSplit	Test.cpp	/^void Test::BitboardTest::testSplit() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testSplitIntoConnectedComponents	Test.cpp	/^void Test::BitboardTest::testSplitIntoConnectedComponents() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testUnionWith	Test.cpp	/^void Test::BitboardTest::testUnionWith() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testXorWith	Test.cpp	/^void Test::BitboardTest::testXorWith() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
unionWith	Bitboard.cpp	/^void BitboardContainer::unionWith( BitboardContainer &other){$/;"	f	class:BitboardContainer	typeref:typename:void
updateArticulationFramework	Hive.cpp	/^void Hive::updateArticulationFramework(vector <PieceNode*> &affectedNodes){$/;"	f	class:Hive	typeref:typename:void
xorWith	Bitboard.cpp	/^void BitboardContainer::xorWith( BitboardContainer &other) {$/;"	f	class:BitboardContainer	typeref:typename:void
