!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	//
ANT	constants.h	/^	ANT,$/;"	e	enum:PieceName
BEETLE	constants.h	/^	BEETLE,$/;"	e	enum:PieceName
BITBOARD_CONTAINER_COLS	constants.h	/^const int BITBOARD_CONTAINER_COLS = 4;$/;"	v	typeref:typename:const int
BITBOARD_CONTAINER_ROWS	constants.h	/^const int BITBOARD_CONTAINER_ROWS = 4;$/;"	v	typeref:typename:const int
BITBOARD_CONTAINER_SIZE	constants.h	/^const int BITBOARD_CONTAINER_SIZE  = 16;$/;"	v	typeref:typename:const int
BITBOARD_HEIGHT	constants.h	/^const int BITBOARD_HEIGHT = 8;$/;"	v	typeref:typename:const int
BITBOARD_WIDTH	constants.h	/^const int BITBOARD_WIDTH = 8;$/;"	v	typeref:typename:const int
BitBoardShiftX	Hive.h	/^	int BitBoardShiftX = 0;$/;"	m	class:Hive	typeref:typename:int
BitBoardShiftY	Hive.h	/^	int BitBoardShiftY = 0;$/;"	m	class:Hive	typeref:typename:int
BitboardContainer	Bitboard.cpp	/^BitboardContainer::BitboardContainer(unordered_map<int, unsigned long long > predefinedBoards){$/;"	f	class:BitboardContainer
BitboardContainer	Bitboard.h	/^	BitboardContainer() {};$/;"	f	class:BitboardContainer
BitboardContainer	Bitboard.h	/^class BitboardContainer {$/;"	c
BitboardTest	Test.h	/^		class BitboardTest {$/;"	c	class:Test
CENTER_X	Hive.h	/^	static const int CENTER_X = 23;$/;"	m	class:Hive	typeref:typename:const int
CENTER_Y	Hive.h	/^	static const int CENTER_Y = 11;$/;"	m	class:Hive	typeref:typename:const int
COLUMN_SHIFT	constants.h	/^const int COLUMN_SHIFT = 1;$/;"	v	typeref:typename:const int
Direction	constants.h	/^enum Direction{$/;"	g
E	constants.h	/^	E = 1,$/;"	e	enum:Direction
GRASSHOPPER	constants.h	/^	GRASSHOPPER=0,$/;"	e	enum:PieceName
Hive	Hive.cpp	/^Hive::Hive() { $/;"	f	class:Hive
Hive	Hive.h	/^class Hive {$/;"	c
HiveTest	Test.h	/^		class HiveTest {$/;"	c	class:Test
LADYBUG	constants.h	/^	LADYBUG,$/;"	e	enum:PieceName
MOSQUITO	constants.h	/^	MOSQUITO,$/;"	e	enum:PieceName
MoveGenerator	MoveGenerator.h	/^		MoveGenerator() {};$/;"	f	class:MoveGenerator
MoveGenerator	MoveGenerator.h	/^class MoveGenerator {$/;"	c
N	constants.h	/^	N = -1,$/;"	e	enum:Direction
NE	constants.h	/^	NE = 0,$/;"	e	enum:Direction
NUM_SPIDER_MOVES	MoveGenerator.h	/^		const int NUM_SPIDER_MOVES = 3;$/;"	m	class:MoveGenerator	typeref:typename:const int
NW	constants.h	/^	NW = 5,$/;"	e	enum:Direction
ODD_ROWS_BITMASK	constants.h	/^const unsigned long long ODD_ROWS_BITMASK = 0xff00ff00ff00ff00u;$/;"	v	typeref:typename:const unsigned long long
PILLBUG	constants.h	/^	PILLBUG,$/;"	e	enum:PieceName
Piece	Piece.cpp	/^Piece::Piece(char pieceColor, string shorthand, int xPos, int yPos) {$/;"	f	class:Piece
Piece	Piece.h	/^	Piece() {};$/;"	f	class:Piece
Piece	Piece.h	/^class Piece {$/;"	c
PieceName	constants.h	/^enum PieceName{$/;"	g
PieceNode	PieceNode.cpp	/^PieceNode::PieceNode(int pieceNum, BitboardContainer b) { $/;"	f	class:PieceNode
PieceNode	PieceNode.h	/^		PieceNode() {};$/;"	f	class:PieceNode
PieceNode	PieceNode.h	/^class PieceNode {$/;"	c
PieceTest	Test.h	/^		class PieceTest {$/;"	c	class:Test
ProblemNodeContainer	ProblemNode.cpp	/^ProblemNodeContainer::ProblemNodeContainer(BitboardContainer * pieces) {$/;"	f	class:ProblemNodeContainer
ProblemNodeContainer	ProblemNode.h	/^class ProblemNodeContainer {$/;"	c
QUEEN	constants.h	/^	QUEEN,$/;"	e	enum:PieceName
ROW_SHIFT	constants.h	/^const int ROW_SHIFT = 8;$/;"	v	typeref:typename:const int
S	constants.h	/^	S = -2$/;"	e	enum:Direction
SE	constants.h	/^	SE = 2,$/;"	e	enum:Direction
SPIDER	constants.h	/^	SPIDER$/;"	e	enum:PieceName
SW	constants.h	/^	SW = 3,$/;"	e	enum:Direction
Test	Test.h	/^class Test {$/;"	c
W	constants.h	/^	W = 4,$/;"	e	enum:Direction
WaspAI	README.md	/^# WaspAI$/;"	c
adjustOverflowMask	Bitboard.cpp	/^unsigned long long BitboardContainer::adjustOverflowMask($/;"	f	class:BitboardContainer	typeref:typename:unsigned long long
allPieces	Hive.h	/^	BitboardContainer allPieces;$/;"	m	class:Hive	typeref:typename:BitboardContainer
allPieces	MoveGenerator.h	/^		BitboardContainer * allPieces;$/;"	m	class:MoveGenerator	typeref:typename:BitboardContainer *
allPieces	ProblemNode.h	/^		BitboardContainer *allPieces;$/;"	m	class:ProblemNodeContainer	typeref:typename:BitboardContainer *
ants	Hive.h	/^	BitboardContainer ants;$/;"	m	class:Hive	typeref:typename:BitboardContainer
articulationNodes	Hive.h	/^	set <PieceNode*> articulationNodes;$/;"	m	class:Hive	typeref:typename:set<PieceNode * >
beetles	Hive.h	/^	BitboardContainer beetles;$/;"	m	class:Hive	typeref:typename:BitboardContainer
bitboard	Piece.h	/^	int bitboard;$/;"	m	class:Piece	typeref:typename:int
bitboard	PieceNode.h	/^		BitboardContainer bitboard;$/;"	m	class:PieceNode	typeref:typename:BitboardContainer
blackPieces	Hive.h	/^	BitboardContainer blackPieces;$/;"	m	class:Hive	typeref:typename:BitboardContainer
boardNumber	Piece.h	/^	int boardNumber;$/;"	m	class:Piece	typeref:typename:int
boundingBoxes	Bitboard.h	/^	int  boundingBoxes[16][4];$/;"	m	class:BitboardContainer	typeref:typename:int[16][4]
clear	Bitboard.cpp	/^void BitboardContainer::clear() {$/;"	f	class:BitboardContainer	typeref:typename:void
clear	ProblemNode.cpp	/^void ProblemNodeContainer::clear() {$/;"	f	class:ProblemNodeContainer	typeref:typename:void
color	Piece.h	/^	char color;$/;"	m	class:Piece	typeref:typename:char
containsAny	Bitboard.cpp	/^bool BitboardContainer::containsAny(BitboardContainer& other) {$/;"	f	class:BitboardContainer	typeref:typename:bool
convertToHexRepresentation	Bitboard.cpp	/^void BitboardContainer::convertToHexRepresentation ($/;"	f	class:BitboardContainer	typeref:typename:void
count	Bitboard.cpp	/^int BitboardContainer::count(){$/;"	f	class:BitboardContainer	typeref:typename:int
createLowOverflowMask	Bitboard.cpp	/^unsigned long long BitboardContainer::createLowOverflowMask(Direction dir, int overflowAmount) {$/;"	f	class:BitboardContainer	typeref:typename:unsigned long long
directions	Test.cpp	/^ unordered_map < string , vector<Direction> > directions = $/;"	v	typeref:typename:unordered_map<string,vector<Direction>>
doors	Hive.h	/^	BitboardContainer doors;$/;"	m	class:Hive	typeref:typename:BitboardContainer
duplicateBoard	Bitboard.cpp	/^void BitboardContainer::duplicateBoard(vector <Direction> dirs){$/;"	f	class:BitboardContainer	typeref:typename:void
dxdy	Test.cpp	/^ int dxdy[6][2] = {{1,1},$/;"	v	typeref:typename:int[6][2]
equals	Bitboard.cpp	/^bool BitboardContainer::equals(BitboardContainer& other){$/;"	f	class:BitboardContainer	typeref:typename:bool
findAllProblemNodes	ProblemNode.cpp	/^void ProblemNodeContainer::findAllProblemNodes() {$/;"	f	class:ProblemNodeContainer	typeref:typename:void
findBoundingBoxes	Bitboard.cpp	/^void BitboardContainer::findBoundingBoxes(){$/;"	f	class:BitboardContainer	typeref:typename:void
findBoundingBoxes	Bitboard.cpp	/^void BitboardContainer::findBoundingBoxes(int boardIndex){$/;"	f	class:BitboardContainer	typeref:typename:void
firstPieces	Hive.h	/^	BitboardContainer firstPieces;$/;"	m	class:Hive	typeref:typename:BitboardContainer
floodFill	Bitboard.cpp	/^void BitboardContainer::floodFill(BitboardContainer &frontier){$/;"	f	class:BitboardContainer	typeref:typename:void
floodFillStep	Bitboard.cpp	/^void BitboardContainer::floodFillStep(BitboardContainer &frontier,  BitboardContainer &visited){$/;"	f	class:BitboardContainer	typeref:typename:void
gates	ProblemNode.cpp	/^BitboardContainer gates[] = {$/;"	v	typeref:typename:BitboardContainer[]
gatesCombined	MoveGenerator.h	/^		BitboardContainer * gatesCombined;$/;"	m	class:MoveGenerator	typeref:typename:BitboardContainer *
gatesSplit	MoveGenerator.h	/^		vector <BitboardContainer> * gatesSplit;$/;"	m	class:MoveGenerator	typeref:typename:vector<BitboardContainer> *
generateAntMoves	MoveGenerator.cpp	/^void MoveGenerator::generateAntMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateBeetleMoves	MoveGenerator.cpp	/^void MoveGenerator::generateBeetleMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateGrasshopperMoves	MoveGenerator.cpp	/^void MoveGenerator::generateGrasshopperMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateLadybugMoves	MoveGenerator.cpp	/^void MoveGenerator::generateLadybugMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateMosquitoMoves	MoveGenerator.cpp	/^void MoveGenerator::generateMosquitoMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generateMoves	MoveGenerator.cpp	/^void MoveGenerator::generateMoves() {$/;"	f	class:MoveGenerator	typeref:typename:void
generatePillbugMoves	MoveGenerator.cpp	/^void MoveGenerator::generatePillbugMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generatePillbugSwap	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::generatePillbugSwap() {$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
generateQueenMoves	MoveGenerator.cpp	/^void MoveGenerator::generateQueenMoves(){ $/;"	f	class:MoveGenerator	typeref:typename:void
generateSpiderMoves	MoveGenerator.cpp	/^void MoveGenerator::generateSpiderMoves(){$/;"	f	class:MoveGenerator	typeref:typename:void
generatingPieceBoard	MoveGenerator.h	/^		BitboardContainer * generatingPieceBoard;$/;"	m	class:MoveGenerator	typeref:typename:BitboardContainer *
generatingPieceName	MoveGenerator.h	/^		PieceName * generatingPieceName;$/;"	m	class:MoveGenerator	typeref:typename:PieceName *
getArticulationNodes	Hive.cpp	/^void Hive::getArticulationNodes(PieceNode &n, int &counter) {$/;"	f	class:Hive	typeref:typename:void
getInaccessibleNodes	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::getInaccessibleNodes(BitboardContainer gates) {$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
getInaccessibleNodes	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::getInaccessibleNodes(vector <BitboardContainer> * gates) {$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
getMoves	MoveGenerator.cpp	/^BitboardContainer MoveGenerator::getMoves() {	$/;"	f	class:MoveGenerator	typeref:typename:BitboardContainer
getPerimeter	Bitboard.cpp	/^BitboardContainer  BitboardContainer::getPerimeter() {$/;"	f	class:BitboardContainer	typeref:typename:BitboardContainer
getPiece	Hive.cpp	/^Piece * Hive::getPiece(char color, string shorthandName){$/;"	f	class:Hive	typeref:typename:Piece *
getPiece	Hive.cpp	/^Piece * Hive::getPiece(int pieceNumber) {$/;"	f	class:Hive	typeref:typename:Piece *
getPieceArray	Hive.cpp	/^Piece * Hive::getPieceArray(){$/;"	f	class:Hive	typeref:typename:Piece *
getPieceLookupSet	Hive.cpp	/^set<int> Hive::getPieceLookupSet(){$/;"	f	class:Hive	typeref:typename:set<int>
getPieceLookupTable	Hive.cpp	/^bool * Hive::getPieceLookupTable(){$/;"	f	class:Hive	typeref:typename:bool *
getProblemNodesAtLocation	ProblemNode.cpp	/^ProblemNodeContainer::getProblemNodesAtLocation(int boardIndex, unsigned long long$/;"	f	class:ProblemNodeContainer	typeref:typename:list<BitboardContainer>
grasshoppers	Hive.h	/^	BitboardContainer grasshoppers;$/;"	m	class:Hive	typeref:typename:BitboardContainer
hash	ProblemNode.cpp	/^int ProblemNodeContainer::hash( BitboardContainer& bitboard){$/;"	f	class:ProblemNodeContainer	typeref:typename:int
hash	ProblemNode.cpp	/^int ProblemNodeContainer::hash(int boardIndex, unsigned long long piece) {$/;"	f	class:ProblemNodeContainer	typeref:typename:int
initialize	Bitboard.cpp	/^void BitboardContainer::initialize(unordered_map < int, unsigned long long> predefinedBoards) {$/;"	f	class:BitboardContainer	typeref:typename:void
initializeTo	Bitboard.cpp	/^void BitboardContainer::initializeTo(BitboardContainer &other) {$/;"	f	class:BitboardContainer	typeref:typename:void
insert	PieceNode.cpp	/^void PieceNode::insert( list <PieceNode*> &newNeighbors, BitboardContainer &newBitboard) {$/;"	f	class:PieceNode	typeref:typename:void
insert	ProblemNode.cpp	/^void ProblemNodeContainer::insert(BitboardContainer& problemNodes) {$/;"	f	class:ProblemNodeContainer	typeref:typename:void
insertPiece	Hive.cpp	/^void Hive::insertPiece(Piece piece){$/;"	f	class:Hive	typeref:typename:void
insertPiece	Hive.cpp	/^void Hive::insertPiece(char pieceColor, string shorthandName,$/;"	f	class:Hive	typeref:typename:void
insertPiece	ProblemNode.cpp	/^void ProblemNodeContainer::insertPiece(BitboardContainer & piece) {$/;"	f	class:ProblemNodeContainer	typeref:typename:void
insertPieceTest	Test.cpp	/^void Test::HiveTest::insertPieceTest() {$/;"	f	class:Test::HiveTest	typeref:typename:void
internalBoardCache	Bitboard.h	/^	set<int> internalBoardCache;$/;"	m	class:BitboardContainer	typeref:typename:set<int>
internalBoards	Bitboard.h	/^	unsigned long long int internalBoards[16];$/;"	m	class:BitboardContainer	typeref:typename:unsigned long long int[16]
intersectionWith	Bitboard.cpp	/^void BitboardContainer::intersectionWith( BitboardContainer &other) {$/;"	f	class:BitboardContainer	typeref:typename:void
isEmpty	PieceNode.h	/^		bool isEmpty = true;$/;"	m	class:PieceNode	typeref:typename:bool
ladybugs	Hive.h	/^	BitboardContainer ladybugs;$/;"	m	class:Hive	typeref:typename:BitboardContainer
locationHashTable	ProblemNode.h	/^		unordered_map <int, list<BitboardContainer>> locationHashTable;$/;"	m	class:ProblemNodeContainer	typeref:typename:unordered_map<int,list<BitboardContainer>>
lowLink	PieceNode.h	/^		int lowLink;$/;"	m	class:PieceNode	typeref:typename:int
main	Test.cpp	/^int main() {$/;"	f	typeref:typename:int
mosquitoes	Hive.h	/^	BitboardContainer mosquitoes;$/;"	m	class:Hive	typeref:typename:BitboardContainer
movePiece	Hive.cpp	/^void Hive::movePiece(char color, string shorthandName, bool right,$/;"	f	class:Hive	typeref:typename:void
movePiece	Hive.cpp	/^void Hive::movePiece(char color, string shorthandName,$/;"	f	class:Hive	typeref:typename:void
movePiece	Hive.cpp	/^void Hive::movePiece(int piece1Int, Direction dir ,int piece2Int){$/;"	f	class:Hive	typeref:typename:void
movePieceTest	Test.cpp	/^void Test::HiveTest::movePieceTest(){$/;"	f	class:Test::HiveTest	typeref:typename:void
moves	MoveGenerator.h	/^		BitboardContainer moves;$/;"	m	class:MoveGenerator	typeref:typename:BitboardContainer
name	Piece.h	/^	string name;$/;"	m	class:Piece	typeref:typename:string
neighbors	PieceNode.h	/^		list <PieceNode*> neighbors;	$/;"	m	class:PieceNode	typeref:typename:list<PieceNode * >
numDirections	Bitboard.cpp	/^int numDirections = 6;$/;"	v	typeref:typename:int
numDirections	ProblemNode.cpp	/^int numDirections = 6;$/;"	v	typeref:typename:int
operator ==	Bitboard.h	/^	bool operator ==(BitboardContainer &other) {$/;"	f	class:BitboardContainer	typeref:typename:bool
oppositeDirection	Bitboard.cpp	/^unordered_map<Direction, Direction> oppositeDirection = $/;"	v	typeref:typename:unordered_map<Direction,Direction>
overflowBitmask	Bitboard.cpp	/^unordered_map <Direction, unsigned long long> overflowBitmask =$/;"	v	typeref:typename:unordered_map<Direction,unsigned long long>
overflowLocation	Bitboard.cpp	/^unordered_map <Direction, vector<int>> overflowLocation =$/;"	v	typeref:typename:unordered_map<Direction,vector<int>>
parameters	Bitboard.cpp	/^unordered_map <Direction, vector<int>> parameters  = {$/;"	v	typeref:typename:unordered_map<Direction,vector<int>>
parent	PieceNode.h	/^		PieceNode * parent;$/;"	m	class:PieceNode	typeref:typename:PieceNode *
parseCommand	Hive.cpp	/^bool Hive::parseCommand(vector<string> command){$/;"	f	class:Hive	typeref:typename:bool
parseCommandTest	Test.cpp	/^void Test::HiveTest::parseCommandTest(){$/;"	f	class:Test::HiveTest	typeref:typename:void
pass	Test.cpp	/^void Test::pass(bool testPassed, string message){$/;"	f	class:Test	typeref:typename:void
perimeter	MoveGenerator.h	/^		BitboardContainer perimeter;$/;"	m	class:MoveGenerator	typeref:typename:BitboardContainer
pieceArray	Hive.h	/^	Piece pieceArray[28];$/;"	m	class:Hive	typeref:typename:Piece[28]
pieceInHive	Hive.cpp	/^bool Hive::pieceInHive(char color, string shorthandName) {$/;"	f	class:Hive	typeref:typename:bool
pieceInHive	Hive.cpp	/^bool Hive::pieceInHive(int pieceNum) {$/;"	f	class:Hive	typeref:typename:bool
pieceIsAtopHive	MoveGenerator.h	/^		bool pieceIsAtopHive;$/;"	m	class:MoveGenerator	typeref:typename:bool
pieceLookupSet	Hive.h	/^	set<int> pieceLookupSet;$/;"	m	class:Hive	typeref:typename:set<int>
pieceLookupTable	Hive.h	/^	bool pieceLookupTable[28];$/;"	m	class:Hive	typeref:typename:bool[28]
pieceName	Piece.cpp	/^unordered_map<string , string> pieceName = {{"Q","queen"},$/;"	v	typeref:typename:unordered_map<string,string>
pieceNodes	Hive.h	/^	list <PieceNode*> pieceNodes; $/;"	m	class:Hive	typeref:typename:list<PieceNode * >
pieceNum	Test.cpp	/^ unordered_map <string, int> pieceNum = {{"Q",0},$/;"	v	typeref:typename:unordered_map<string,int>
pieceNumber	Hive.cpp	/^int Hive::pieceNumber(Piece piece){$/;"	f	class:Hive	typeref:typename:int
pieceNumber	Hive.cpp	/^int Hive::pieceNumber(char color, string shorthandName) {$/;"	f	class:Hive	typeref:typename:int
pieceNumber	PieceNode.h	/^		int pieceNumber;$/;"	m	class:PieceNode	typeref:typename:int
pillbugs	Hive.h	/^	BitboardContainer pillbugs;$/;"	m	class:Hive	typeref:typename:BitboardContainer
potentialProblemNodes	ProblemNode.cpp	/^BitboardContainer potentialProblemNodes[] = {$/;"	v	typeref:typename:BitboardContainer[]
print	Hive.cpp	/^void Hive::print() {$/;"	f	class:Hive	typeref:typename:void
printDebug	Hive.cpp	/^void Hive::printDebug() {$/;"	f	class:Hive	typeref:typename:void
problemNodeHashes	ProblemNode.h	/^		unordered_set <int> problemNodeHashes;$/;"	m	class:ProblemNodeContainer	typeref:typename:unordered_set<int>
problemNodes	Hive.h	/^	BitboardContainer problemNodes;$/;"	m	class:Hive	typeref:typename:BitboardContainer
pruneCache	Bitboard.cpp	/^void BitboardContainer::pruneCache(){$/;"	f	class:BitboardContainer	typeref:typename:void
queens	Hive.h	/^	BitboardContainer queens;$/;"	m	class:Hive	typeref:typename:BitboardContainer
removePiece	ProblemNode.cpp	/^void ProblemNodeContainer::removePiece( BitboardContainer & piece) {$/;"	f	class:ProblemNodeContainer	typeref:typename:void
reposition	PieceNode.cpp	/^void PieceNode::reposition(list <PieceNode*> &newNeighbors, BitboardContainer &newBitboard){$/;"	f	class:PieceNode	typeref:typename:void
rings	Hive.h	/^	BitboardContainer rings;$/;"	m	class:Hive	typeref:typename:BitboardContainer
secondPieces	Hive.h	/^	BitboardContainer secondPieces;$/;"	m	class:Hive	typeref:typename:BitboardContainer
setBoard	Bitboard.cpp	/^void BitboardContainer::setBoard(int boardIndex, unsigned long long board) {$/;"	f	class:BitboardContainer	typeref:typename:void
setGatesSplit	MoveGenerator.cpp	/^void MoveGenerator::setGatesSplit( vector <BitboardContainer> * p){$/;"	f	class:MoveGenerator	typeref:typename:void
shiftDirection	Bitboard.cpp	/^void BitboardContainer::shiftDirection(Direction dir) {$/;"	f	class:BitboardContainer	typeref:typename:void
shiftDirection	Bitboard.cpp	/^void BitboardContainer::shiftDirection(Direction dir, int numTimes){$/;"	f	class:BitboardContainer	typeref:typename:void
shiftDirection	PieceNode.cpp	/^void PieceNode::shiftDirection(Direction dir) {$/;"	f	class:PieceNode	typeref:typename:void
shiftDirection	PieceNode.cpp	/^void PieceNode::shiftDirection(Direction dir, int numTimes) {$/;"	f	class:PieceNode	typeref:typename:void
shiftOrthogonalDirection	Bitboard.cpp	/^void BitboardContainer::shiftOrthogonalDirection(Direction dir, int numTimes){$/;"	f	class:BitboardContainer	typeref:typename:void
shorthandName	Piece.h	/^	string shorthandName;$/;"	m	class:Piece	typeref:typename:string
silent	Test.cpp	/^bool Test::silent = false;$/;"	m	class:Test	typeref:typename:bool
silent	Test.h	/^		static bool silent;$/;"	m	class:Test	typeref:typename:bool
spiders	Hive.h	/^	BitboardContainer spiders;$/;"	m	class:Hive	typeref:typename:BitboardContainer
split	Bitboard.cpp	/^unordered_map< int, vector < unsigned long long >> BitboardContainer::split(){$/;"	f	class:BitboardContainer	typeref:typename:unordered_map<int,vector<unsigned long long>>
splitIntoBitboardContainers	Bitboard.cpp	/^list <BitboardContainer> BitboardContainer::splitIntoBitboardContainers() {$/;"	f	class:BitboardContainer	typeref:typename:list<BitboardContainer>
splitIntoConnectedComponents	Bitboard.cpp	/^vector <BitboardContainer> BitboardContainer::splitIntoConnectedComponents(){$/;"	f	class:BitboardContainer	typeref:typename:vector<BitboardContainer>
testBitboardBoundings	Test.cpp	/^void Test::BitboardTest::testBitboardBoundings(){$/;"	f	class:Test::BitboardTest	typeref:typename:void
testContainsAny	Test.cpp	/^void Test::BitboardTest::testContainsAny() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testFindAllProblemNodes	Test.cpp	/^void Test::BitboardTest::testFindAllProblemNodes(){$/;"	f	class:Test::BitboardTest	typeref:typename:void
testFloodFill	Test.cpp	/^void Test::BitboardTest::testFloodFill() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testFloodFillStep	Test.cpp	/^void Test::BitboardTest::testFloodFillStep() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testIntersectionWith	Test.cpp	/^void Test::BitboardTest::testIntersectionWith() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testShiftDirection	Test.cpp	/^void Test::BitboardTest::testShiftDirection(){$/;"	f	class:Test::BitboardTest	typeref:typename:void
testSplit	Test.cpp	/^void Test::BitboardTest::testSplit() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testSplitIntoConnectedComponents	Test.cpp	/^void Test::BitboardTest::testSplitIntoConnectedComponents() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testUnionWith	Test.cpp	/^void Test::BitboardTest::testUnionWith() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
testXorWith	Test.cpp	/^void Test::BitboardTest::testXorWith() {$/;"	f	class:Test::BitboardTest	typeref:typename:void
thirdPieces	Hive.h	/^	BitboardContainer thirdPieces;$/;"	m	class:Hive	typeref:typename:BitboardContainer
turnCounter	Hive.h	/^	int turnCounter = 0;$/;"	m	class:Hive	typeref:typename:int
unionWith	Bitboard.cpp	/^void BitboardContainer::unionWith( BitboardContainer &other){$/;"	f	class:BitboardContainer	typeref:typename:void
updateArticulationFramework	Hive.cpp	/^void Hive::updateArticulationFramework(vector <PieceNode*> &affectedNodes){$/;"	f	class:Hive	typeref:typename:void
updateVisible	ProblemNode.cpp	/^void ProblemNodeContainer::updateVisible(BitboardContainer& locations) {$/;"	f	class:ProblemNodeContainer	typeref:typename:void
visibleProblemNodes	ProblemNode.h	/^		BitboardContainer visibleProblemNodes;$/;"	m	class:ProblemNodeContainer	typeref:typename:BitboardContainer
visited	PieceNode.h	/^		bool visited = false;$/;"	m	class:PieceNode	typeref:typename:bool
visitedNum	PieceNode.h	/^		int visitedNum;$/;"	m	class:PieceNode	typeref:typename:int
whitePieces	Hive.h	/^	BitboardContainer whitePieces;$/;"	m	class:Hive	typeref:typename:BitboardContainer
x	Piece.h	/^	int x;$/;"	m	class:Piece	typeref:typename:int
xorWith	Bitboard.cpp	/^void BitboardContainer::xorWith( BitboardContainer &other) {$/;"	f	class:BitboardContainer	typeref:typename:void
y	Piece.h	/^	int y;$/;"	m	class:Piece	typeref:typename:int
