!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ANT	constants.h	/^	ANT=6,$/;"	e	enum:PieceName
AlphaBeta	AlphaBeta.h	/^		AlphaBeta(GameState init, Heuristic & h) :rootGameState(init),heuristic(h){};$/;"	f	class:AlphaBeta
AlphaBeta	AlphaBeta.h	/^class AlphaBeta{$/;"	c
Arena	Arena.h	/^		Arena(GameState g):currentGameState(g){};$/;"	f	class:Arena
Arena	Arena.h	/^class Arena {$/;"	c
ArenaTest	Test.h	/^		class ArenaTest {$/;"	c	class:Test
BEETLE	constants.h	/^	BEETLE=5,$/;"	e	enum:PieceName
BITBOARD_COLS	constants.h	/^const int BITBOARD_COLS = 3;$/;"	v
BITBOARD_HEIGHT	constants.h	/^const int BITBOARD_HEIGHT = 8;$/;"	v
BITBOARD_ROWS	constants.h	/^const int BITBOARD_ROWS = 3;$/;"	v
BITBOARD_SIZE	constants.h	/^const int BITBOARD_SIZE  = 9;$/;"	v
BITBOARD_WIDTH	constants.h	/^const int BITBOARD_WIDTH = 8;$/;"	v
BLACK	constants.h	/^	BLACK = 1,$/;"	e	enum:PieceColor
Bitboard	Bitboard.cpp	/^Bitboard::Bitboard(unordered_map<int, unsigned long long > predefinedBoards){$/;"	f	class:Bitboard
Bitboard	Bitboard.h	/^	Bitboard() {};$/;"	f	class:Bitboard
Bitboard	Bitboard.h	/^class Bitboard {$/;"	c
BitboardTest	Test.h	/^		class BitboardTest {$/;"	c	class:Test
COLUMN_SHIFT	constants.h	/^const int COLUMN_SHIFT = 1;$/;"	v
CPU	Arena.h	/^		MonteCarloTree CPU[2];$/;"	m	class:Arena
CXX	Makefile	/^CXX=g++$/;"	m
CXXFLAGSDEBUG	Makefile	/^CXXFLAGSDEBUG=-Wall -Wextra -ggdb -pthread$/;"	m
CXXFLAGSRELEASE	Makefile	/^CXXFLAGSRELEASE=-O3 -Wall -pthread$/;"	m
Complexity	constants.h	/^enum Complexity {$/;"	g
DEBUG	Makefile	/^DEBUG=-o test.out$/;"	m
DEPENDENCIES	Makefile	/^DEPENDENCIES=Bitboard.o\\$/;"	m
DFS	PieceGraph.cpp	/^unordered_set <PieceNode*> PieceGraph::DFS() {$/;"	f	class:PieceGraph
DFS	PieceGraph.cpp	/^void PieceGraph::DFS( PieceNode * root,$/;"	f	class:PieceGraph
Direction	constants.h	/^enum Direction{$/;"	g
E	constants.h	/^	E = 1,$/;"	e	enum:Direction
GATES	Test.cpp	/^unordered_map <unsigned long long , unsigned long long > GATES[64];$/;"	v
GRASSHOPPER	constants.h	/^	GRASSHOPPER=0,$/;"	e	enum:PieceName
GameState	GameState.cpp	/^GameState::GameState (vector <unordered_map <PieceName, int>> unusedPiecesIn, $/;"	f	class:GameState
GameState	GameState.cpp	/^GameState::GameState(const GameState& other) {$/;"	f	class:GameState
GameState	GameState.h	/^	GameState(){};$/;"	f	class:GameState
GameState	GameState.h	/^class GameState {$/;"	c
GameStateTest	Test.h	/^		class GameStateTest {$/;"	c	class:Test
Heuristic	Heuristic.cpp	/^Heuristic::Heuristic (Complexity c, set<char> pieces) {$/;"	f	class:Heuristic
Heuristic	Heuristic.h	/^		Heuristic(){};$/;"	f	class:Heuristic
Heuristic	Heuristic.h	/^class Heuristic {$/;"	c
HiveOriginal	constants.cpp	/^vector < unordered_map <PieceName, int>> HiveOriginal = $/;"	v
HivePLM	constants.cpp	/^vector < unordered_map <PieceName, int>> HivePLM = $/;"	v
HiveTest	Test.h	/^		class HiveTest {$/;"	c	class:Test
INF	AlphaBeta.h	4;"	d
IntermediateGraph	PieceGraph.h	/^		IntermediateGraph(){$/;"	f	class:IntermediateGraph
IntermediateGraph	PieceGraph.h	/^class IntermediateGraph {$/;"	c
KillShotCountWeight	Weight.h	/^		KillShotCountWeight(double multiplier) :Weight(multiplier){};$/;"	f	class:KillShotCountWeight
KillShotCountWeight	Weight.h	/^class KillShotCountWeight: public Weight {$/;"	c
LADYBUG	constants.h	/^	LADYBUG=2,$/;"	e	enum:PieceName
LEARNING_RATE	constants.cpp	/^double LEARNING_RATE = 0.2;$/;"	v
LENGTH	constants.h	/^	LENGTH=8,$/;"	e	enum:PieceName
MOSQUITO	constants.h	/^	MOSQUITO=4,$/;"	e	enum:PieceName
MonteCarloNode	MonteCarloNode.h	/^		MonteCarloNode(){};$/;"	f	class:MonteCarloNode
MonteCarloNode	MonteCarloNode.h	/^class MonteCarloNode{$/;"	c
MonteCarloSimulations	constants.cpp	/^int MonteCarloSimulations = 100;$/;"	v
MonteCarloSimulationsCutoff	constants.cpp	/^int MonteCarloSimulationsCutoff = 500;$/;"	v
MonteCarloTest	Test.h	/^		class MonteCarloTest {$/;"	c	class:Test
MonteCarloTree	MonteCarloTree.h	/^		MonteCarloTree(){};$/;"	f	class:MonteCarloTree
MonteCarloTree	MonteCarloTree.h	/^		MonteCarloTree(Heuristic& h)$/;"	f	class:MonteCarloTree
MonteCarloTree	MonteCarloTree.h	/^class MonteCarloTree {$/;"	c
MoveGenerator	MoveGenerator.cpp	/^MoveGenerator::MoveGenerator(Bitboard * allPiecesIn) {$/;"	f	class:MoveGenerator
MoveGenerator	MoveGenerator.h	/^		MoveGenerator(){};$/;"	f	class:MoveGenerator
MoveGenerator	MoveGenerator.h	/^class MoveGenerator {$/;"	c
MoveGeneratorTest	Test.h	/^		class MoveGeneratorTest {$/;"	c	class:Test
MoveGraph	PieceGraph.h	/^class MoveGraph : public PieceGraph{$/;"	c
MoveInfo	GameState.h	/^struct MoveInfo {$/;"	s
N	constants.h	/^	N = -1,$/;"	e	enum:Direction
NE	constants.h	/^	NE = 0,$/;"	e	enum:Direction
NONE	constants.h	/^	NONE = 2$/;"	e	enum:PieceColor
NUMWEIGHTS	Heuristic.h	/^		int NUMWEIGHTS;$/;"	m	class:Heuristic
NUM_SPIDER_MOVES	MoveGenerator.h	/^		const int NUM_SPIDER_MOVES = 3;$/;"	m	class:MoveGenerator
NW	constants.h	/^	NW = 5,$/;"	e	enum:Direction
ODD_ROWS_BITMASK	constants.h	/^const unsigned long long ODD_ROWS_BITMASK = 0xff00ff00ff00ff00u;$/;"	v
PERIMETER	Test.cpp	/^vector <unordered_map<unsigned long long, unsigned long long[5]>> PERIMETER = {{{}}};$/;"	v
PERIMETER_SIZE	Test.cpp	/^int PERIMETER_SIZE = 2;$/;"	v
PILLBUG	constants.h	/^	PILLBUG=3,$/;"	e	enum:PieceName
PieceColor	constants.h	/^enum PieceColor {$/;"	g
PieceCountWeight	Weight.h	/^		PieceCountWeight(double multiplier) :Weight(multiplier) {};$/;"	f	class:PieceCountWeight
PieceCountWeight	Weight.h	/^class PieceCountWeight : public Weight{$/;"	c
PieceGraph	PieceGraph.h	/^class PieceGraph {$/;"	c
PieceGraphTest	Test.h	/^		class PieceGraphTest {$/;"	c	class:Test
PieceName	constants.h	/^enum PieceName{$/;"	g
PieceNode	PieceNode.h	/^		PieceNode(){};$/;"	f	class:PieceNode
PieceNode	PieceNode.h	/^class PieceNode {$/;"	c
PinnedWeight	Weight.h	/^		PinnedWeight(double multiplier) : Weight(multiplier) {};$/;"	f	class:PinnedWeight
PinnedWeight	Weight.h	/^class PinnedWeight : public Weight {$/;"	c
PinningPowerWeight	Weight.h	/^		PinningPowerWeight(unordered_map<PieceName, double> initialMap){$/;"	f	class:PinningPowerWeight
PinningPowerWeight	Weight.h	/^class PinningPowerWeight : public Weight {$/;"	c
ProblemNodeContainer	ProblemNode.cpp	/^ProblemNodeContainer::ProblemNodeContainer(Bitboard * pieces) {$/;"	f	class:ProblemNodeContainer
ProblemNodeContainer	ProblemNode.h	/^		ProblemNodeContainer(){};$/;"	f	class:ProblemNodeContainer
ProblemNodeContainer	ProblemNode.h	/^class ProblemNodeContainer {$/;"	c
ProblemNodeContainerTest	Test.h	/^		class ProblemNodeContainerTest {$/;"	c	class:Test
QUEEN	constants.h	/^	QUEEN=1,$/;"	e	enum:PieceName
RANDOM	constants.h	/^	RANDOM=0,$/;"	e	enum:Complexity
RELEASE	Makefile	/^RELEASE=-o test.out$/;"	m
ROW_SHIFT	constants.h	/^const int ROW_SHIFT = 8;$/;"	v
RandomWeight	Weight.h	/^		RandomWeight():Weight{0}{};$/;"	f	class:RandomWeight
RandomWeight	Weight.h	/^class RandomWeight: public Weight {$/;"	c
S	constants.h	/^	S = -2,$/;"	e	enum:Direction
SE	constants.h	/^	SE = 2,$/;"	e	enum:Direction
SIMPLE	constants.h	/^	SIMPLE=1,$/;"	e	enum:Complexity
SPIDER	constants.h	/^	SPIDER=7,$/;"	e	enum:PieceName
SW	constants.h	/^	SW = 3,$/;"	e	enum:Direction
Test	Test.h	/^class Test {$/;"	c
W	constants.h	/^	W = 4,$/;"	e	enum:Direction
WHITE	constants.h	/^	WHITE = 0,$/;"	e	enum:PieceColor
Weight	Weight.h	/^		Weight (){}$/;"	f	class:Weight
Weight	Weight.h	/^		Weight (double multiplier): multiplier(multiplier){};$/;"	f	class:Weight
Weight	Weight.h	/^class Weight {$/;"	c
WeightTest	Test.h	/^		class WeightTest{$/;"	c	class:Test
adjustOverflowMask	Bitboard.cpp	/^unsigned long long Bitboard::adjustOverflowMask($/;"	f	class:Bitboard
allNodes	PieceGraph.h	/^		Bitboard allNodes;$/;"	m	class:IntermediateGraph
allPieces	GameState.h	/^	Bitboard allPieces;$/;"	m	class:GameState
allPieces	MoveGenerator.h	/^		Bitboard * allPieces;$/;"	m	class:MoveGenerator
allPieces	PieceGraph.h	/^		Bitboard allPieces;$/;"	m	class:PieceGraph
allPieces	ProblemNode.h	/^		Bitboard *allPieces;$/;"	m	class:ProblemNodeContainer
alpha	AlphaBeta.h	/^		double alpha = -INF;$/;"	m	class:AlphaBeta
ants	GameState.h	/^	Bitboard ants;$/;"	m	class:GameState
approximate	MoveGenerator.h	/^		bool approximate = false;$/;"	m	class:MoveGenerator
approximateEndResult	GameState.cpp	/^double GameState::approximateEndResult() {$/;"	f	class:GameState
articulationLocations	PieceGraph.h	/^		Bitboard articulationLocations;$/;"	m	class:MoveGraph
assignNode	PieceGraph.h	/^		void assignNode(Bitboard& node, int num){$/;"	f	class:IntermediateGraph
attemptMove	GameState.cpp	/^bool GameState::attemptMove(vector<movesCollection>& approxMovesPerPiece, int total){$/;"	f	class:GameState
attemptSpawn	GameState.cpp	/^bool GameState::attemptSpawn(int totalApproxMoves) {$/;"	f	class:GameState
backPropagate	MonteCarloTree.cpp	/^void MonteCarloTree::backPropagate(nodePtr leafPtr, double result){$/;"	f	class:MonteCarloTree
battle	Arena.cpp	/^bool Arena::battle(bool silent) {$/;"	f	class:Arena
beetles	GameState.h	/^	Bitboard beetles;$/;"	m	class:GameState
begin	Bitboard.cpp	/^list <Bitboard>::const_iterator Bitboard::begin() {$/;"	f	class:Bitboard
beta	AlphaBeta.h	/^		double beta = INF;$/;"	m	class:AlphaBeta
blackPieces	GameState.h	/^	Bitboard blackPieces;$/;"	m	class:GameState
boardIndex	PieceNode.h	/^		int boardIndex = -1;$/;"	m	class:PieceNode
calculate	Weight.h	/^		double calculate(MoveInfo) {return 0;};$/;"	f	class:RandomWeight
changeTurnColor	GameState.cpp	/^void GameState::changeTurnColor() {$/;"	f	class:GameState
checkArticulationRoot	PieceGraph.cpp	/^void PieceGraph::checkArticulationRoot(PieceNode * root) {$/;"	f	class:PieceGraph
checkBiDirectional	PieceGraph.cpp	/^bool PieceGraph::checkBiDirectional(Bitboard a, Bitboard b) {$/;"	f	class:PieceGraph
checkDraw	GameState.cpp	/^bool GameState::checkDraw() {$/;"	f	class:GameState
checkLegalWalk	MoveGenerator.cpp	/^bool checkLegalWalk(Bitboard& allPieces, Bitboard& board, Direction dir) {$/;"	f
checkVictory	GameState.cpp	/^PieceColor GameState::checkVictory() {$/;"	f	class:GameState
children	MonteCarloNode.h	/^		unordered_map <MoveInfo, nodePtr> children;$/;"	m	class:MonteCarloNode
clear	Bitboard.cpp	/^void Bitboard::clear() {$/;"	f	class:Bitboard
clear	PieceGraph.h	/^		void clear(){$/;"	f	class:IntermediateGraph
clear	ProblemNode.cpp	/^void ProblemNodeContainer::clear() {$/;"	f	class:ProblemNodeContainer
clearChildren	MonteCarloNode.h	/^		void clearChildren() {$/;"	f	class:MonteCarloNode
clearParent	MonteCarloNode.h	/^		void clearParent() {$/;"	f	class:MonteCarloNode
complexity	Heuristic.h	/^		Complexity complexity;$/;"	m	class:Heuristic
contains	ProblemNode.cpp	/^bool ProblemNodeContainer::contains(Bitboard& piece){$/;"	f	class:ProblemNodeContainer
containsAll	Bitboard.cpp	/^bool Bitboard::containsAll(Bitboard& other) {$/;"	f	class:Bitboard
containsAny	Bitboard.cpp	/^bool Bitboard::containsAny(Bitboard& other) {$/;"	f	class:Bitboard
convertFromNotation	Arena.cpp	/^MoveInfo Arena::convertFromNotation(string notation) {$/;"	f	class:Arena
convertToHexRepresentation	Bitboard.cpp	/^void Bitboard::convertToHexRepresentation ( Direction lastMovedDir , int lastMovedTimes) {$/;"	f	class:Bitboard
convertToNotation	Arena.cpp	/^string Arena::convertToNotation(MoveInfo move){$/;"	f	class:Arena
correct	Weight.h	/^		virtual void correct(double amount){$/;"	f	class:Weight
count	Bitboard.cpp	/^int Bitboard::count() const{$/;"	f	class:Bitboard
countPieces	Arena.cpp	/^int Arena::countPieces(PieceColor color, PieceName name){$/;"	f	class:Arena
countSwaps	GameState.cpp	/^int	 GameState::countSwaps(Bitboard& piece){$/;"	f	class:GameState
countTotalUnusedPieces	GameState.cpp	/^int GameState::countTotalUnusedPieces() {$/;"	f	class:GameState
createChild	MonteCarloNode.h	/^		void createChild(MoveInfo m) {$/;"	f	class:MonteCarloNode
createGateHashTable	Test.cpp	/^void createGateHashTable() {$/;"	f
createLowOverflowMask	Bitboard.cpp	/^unsigned long long Bitboard::createLowOverflowMask(Direction dir, int overflowAmount) {$/;"	f	class:Bitboard
createPerimeterHashTable	Test.cpp	/^void createPerimeterHashTable(int maxNumber) {$/;"	f
currentGameState	Arena.h	/^		GameState currentGameState;$/;"	m	class:Arena
currentHeuristic	MonteCarloTree.h	/^		Heuristic currentHeuristic;$/;"	m	class:MonteCarloTree
depth	Heuristic.h	/^		int depth = 0;$/;"	m	class:Heuristic
destroy	GameState.cpp	/^void GameState::destroy() {$/;"	f	class:GameState
destroy	PieceGraph.cpp	/^void MoveGraph::destroy(){$/;"	f	class:MoveGraph
destroy	PieceGraph.cpp	/^void PieceGraph::destroy() {$/;"	f	class:PieceGraph
directions	Test.cpp	/^ unordered_map < string , vector<Direction> > directions = $/;"	v
distr	Bitboard.cpp	/^std::uniform_int_distribution<unsigned long long> distr;$/;"	v
duplicateBoard	Bitboard.cpp	/^void Bitboard::duplicateBoard(list <Direction> dirs){$/;"	f	class:Bitboard
dxdy	Test.cpp	/^ int dxdy[6][2] = {{1,1},$/;"	v
elbowPinWeight	Weight.h	/^		double elbowPinWeight =  .5;$/;"	m	class:PinningPowerWeight
equals	Bitboard.cpp	/^bool Bitboard::equals(Bitboard& other){$/;"	f	class:Bitboard
evaluate	Heuristic.cpp	/^vector<double> Heuristic::evaluate(MoveInfo m){$/;"	f	class:Heuristic
evaluate	MonteCarloNode.h	/^		inline void evaluate(Heuristic& h, MoveInfo m){$/;"	f	class:MonteCarloNode
evaluate	Weight.cpp	/^double KillShotCountWeight::evaluate(MoveInfo move){$/;"	f	class:KillShotCountWeight
evaluate	Weight.cpp	/^double PieceCountWeight::evaluate(MoveInfo move) {$/;"	f	class:PieceCountWeight
evaluate	Weight.cpp	/^double PinnedWeight::evaluate(MoveInfo move){$/;"	f	class:PinnedWeight
evaluate	Weight.cpp	/^double PinningPowerWeight::evaluate(MoveInfo move){$/;"	f	class:PinningPowerWeight
evaluate	Weight.h	/^		virtual double evaluate(MoveInfo){return 0;};$/;"	f	class:Weight
evaluateAllChildren	MonteCarloNode.h	/^		void evaluateAllChildren(Heuristic& h,GameState& gameState) {$/;"	f	class:MonteCarloNode
expand	MonteCarloTree.cpp	/^MoveInfo MonteCarloTree::expand(nodePtr leafPtr, GameState leafGameState) {$/;"	f	class:MonteCarloTree
expansionPieces	Heuristic.h	/^		set<char> expansionPieces;$/;"	m	class:Heuristic
explorationFactor	constants.cpp	/^double explorationFactor = 1.41;$/;"	v
extraInfo	MoveGenerator.h	/^		Bitboard extraInfo;$/;"	m	class:MoveGenerator
extraInfoOn	MoveGenerator.h	/^		bool extraInfoOn = false;$/;"	m	class:MoveGenerator
fastInsertPiece	GameState.cpp	/^void GameState::fastInsertPiece(Bitboard& bitboard, PieceName name, PieceColor color) {$/;"	f	class:GameState
fastMovePiece	GameState.cpp	/^void GameState::fastMovePiece(Bitboard& oldBitboard, Bitboard& newBitboard) {$/;"	f	class:GameState
fastRemovePiece	GameState.cpp	/^void GameState::fastRemovePiece(Bitboard& oldBitboard){ $/;"	f	class:GameState
fastSpawnPiece	GameState.cpp	/^void GameState::fastSpawnPiece(Bitboard& b, PieceName n) {$/;"	f	class:GameState
find	PieceGraph.h	/^		vector<int> find(Bitboard& test){$/;"	f	class:IntermediateGraph
findAllProblemNodes	ProblemNode.cpp	/^void ProblemNodeContainer::findAllProblemNodes() {$/;"	f	class:ProblemNodeContainer
findBottomPieceColor	GameState.cpp	/^PieceColor GameState::findBottomPieceColor(Bitboard piece) {$/;"	f	class:GameState
findBottomPieceName	GameState.cpp	/^PieceName GameState::findBottomPieceName(Bitboard piece) {$/;"	f	class:GameState
findPinnedPieces	GameState.cpp	/^inline void GameState::findPinnedPieces(){$/;"	f	class:GameState
findTopPieceColor	GameState.cpp	/^PieceColor GameState::findTopPieceColor( Bitboard piece) {$/;"	f	class:GameState
findTopPieceName	GameState.cpp	/^PieceName GameState::findTopPieceName(Bitboard piece) {$/;"	f	class:GameState
findTopPieceOrder	Arena.cpp	/^string Arena::findTopPieceOrder(Bitboard piece){$/;"	f	class:Arena
floodFill	Bitboard.cpp	/^void Bitboard::floodFill(Bitboard &frontier){$/;"	f	class:Bitboard
floodFillStep	Bitboard.cpp	/^void Bitboard::floodFillStep(Bitboard &frontier,  Bitboard &visited){$/;"	f	class:Bitboard
gameState	Heuristic.h	/^		GameState * gameState = nullptr;$/;"	m	class:Heuristic
gateInDirection	ProblemNode.cpp	/^unordered_map <Direction, unsigned long long> gateInDirection = {$/;"	v
gates	ProblemNode.cpp	/^Bitboard gates[] = {$/;"	v
generateAllMoves	GameState.cpp	/^vector<MoveInfo> GameState::generateAllMoves() {$/;"	f	class:GameState
generateApproxAntMoves	MoveGenerator.cpp	/^void MoveGenerator::generateApproxAntMoves() {$/;"	f	class:MoveGenerator
generateBeetleMoves	MoveGenerator.cpp	/^void MoveGenerator::generateBeetleMoves(){$/;"	f	class:MoveGenerator
generateDirectionCombinations	Test.cpp	/^void generateDirectionCombinations (unsigned int i, vector < vector <Direction>>& v) {$/;"	f
generateGrasshopperMoves	MoveGenerator.cpp	/^void MoveGenerator::generateGrasshopperMoves(){$/;"	f	class:MoveGenerator
generateLadybugMoves	MoveGenerator.cpp	/^void MoveGenerator::generateLadybugMoves(){$/;"	f	class:MoveGenerator
generateLegalAntMoves	MoveGenerator.cpp	/^void MoveGenerator::generateLegalAntMoves() {$/;"	f	class:MoveGenerator
generateMosquitoMoves	MoveGenerator.cpp	/^void MoveGenerator::generateMosquitoMoves(){$/;"	f	class:MoveGenerator
generateMoves	MoveGenerator.cpp	/^void MoveGenerator::generateMoves() {$/;"	f	class:MoveGenerator
generateMovesPerfTest	Test.cpp	/^void generateMovesPerfTest() {$/;"	f
generatePillbugMoves	MoveGenerator.cpp	/^void MoveGenerator::generatePillbugMoves(){$/;"	f	class:MoveGenerator
generateQueenMoves	MoveGenerator.cpp	/^void MoveGenerator::generateQueenMoves(){ $/;"	f	class:MoveGenerator
generateSpiderMoves	MoveGenerator.cpp	/^void MoveGenerator::generateSpiderMoves(){$/;"	f	class:MoveGenerator
generatingPieceBoard	MoveGenerator.h	/^		Bitboard * generatingPieceBoard;$/;"	m	class:MoveGenerator
generatingPieceName	MoveGenerator.h	/^		PieceName * generatingPieceName;$/;"	m	class:MoveGenerator
getAllMoves	GameState.cpp	/^void GameState::getAllMoves() {$/;"	f	class:GameState
getAllMovesCount	GameState.cpp	/^int GameState::getAllMovesCount() {$/;"	f	class:GameState
getAllSpawnSpaces	GameState.cpp	/^Bitboard GameState::getAllSpawnSpaces() {$/;"	f	class:GameState
getArticulationNodes	PieceGraph.cpp	/^void MoveGraph::getArticulationNodes(Bitboard root) {$/;"	f	class:MoveGraph
getArticulationNodes	PieceGraph.cpp	/^void PieceGraph::getArticulationNodes(PieceNode * n, int& counter, $/;"	f	class:PieceGraph
getEndNodes	PieceGraph.h	/^		Bitboard getEndNodes() {$/;"	f	class:IntermediateGraph
getIntermediateNodes	PieceGraph.h	/^		Bitboard getIntermediateNodes(){$/;"	f	class:IntermediateGraph
getLeastSignificantBit	Bitboard.cpp	/^Bitboard::getLeastSignificantBit () const {$/;"	f	class:Bitboard
getLegalClimb	MoveGenerator.cpp	/^Bitboard MoveGenerator::getLegalClimb( Bitboard& board, Direction dir) {$/;"	f	class:MoveGenerator
getLegalClimbs	MoveGenerator.cpp	/^Bitboard MoveGenerator::getLegalClimbs( Bitboard& board){$/;"	f	class:MoveGenerator
getLegalConnectedComponents	MoveGenerator.cpp	/^Bitboard MoveGenerator::getLegalConnectedComponents(Bitboard test) {$/;"	f	class:MoveGenerator
getLegalWalkPerimeter	MoveGenerator.cpp	/^Bitboard MoveGenerator::getLegalWalkPerimeter(Bitboard board) {$/;"	f	class:MoveGenerator
getLegalWalks	MoveGenerator.cpp	/^Bitboard getLegalWalks(Bitboard& board, Bitboard& allPieces) {$/;"	f
getMosquitoMoves	GameState.cpp	/^Bitboard GameState::getMosquitoMoves(Bitboard piece) {$/;"	f	class:GameState
getMosquitoPillbug	GameState.cpp	/^Bitboard GameState::getMosquitoPillbug() {$/;"	f	class:GameState
getMoves	MoveGenerator.cpp	/^Bitboard MoveGenerator::getMoves() {	$/;"	f	class:MoveGenerator
getMoves	PieceGraph.cpp	/^Bitboard MoveGraph::getMoves(){$/;"	f	class:MoveGraph
getNodes	PieceGraph.h	/^		Bitboard getNodes() {$/;"	f	class:IntermediateGraph
getPerimeter	Bitboard.cpp	/^Bitboard  Bitboard::getPerimeter() {$/;"	f	class:Bitboard
getPerimeter	ProblemNode.cpp	/^Bitboard ProblemNodeContainer::getPerimeter(Bitboard& pieces) {$/;"	f	class:ProblemNodeContainer
getPieces	GameState.cpp	/^Bitboard * GameState::getPieces(PieceColor color) {$/;"	f	class:GameState
getPieces	GameState.cpp	/^Bitboard * GameState::getPieces(PieceName name) {$/;"	f	class:GameState
getPieces	GameState.cpp	/^inline Bitboard * GameState::getPieces() { $/;"	f	class:GameState
getPillbugSwapSpaces	MoveGenerator.cpp	/^Bitboard MoveGenerator::getPillbugSwapSpaces() {$/;"	f	class:MoveGenerator
getPinnedPieces	PieceGraph.cpp	/^Bitboard PieceGraph::getPinnedPieces(Bitboard root) {$/;"	f	class:PieceGraph
getProblemNodesAtLocation	ProblemNode.cpp	/^ProblemNodeContainer::getProblemNodesAtLocation(int boardIndex, unsigned long long$/;"	f	class:ProblemNodeContainer
getRandom	Bitboard.cpp	/^Bitboard Bitboard::getRandom() {$/;"	f	class:Bitboard
getRandomBoardIndex	Bitboard.cpp	/^int Bitboard::getRandomBoardIndex() {$/;"	f	class:Bitboard
getSwapSpaces	GameState.cpp	/^pair <Bitboard, Bitboard> GameState::getSwapSpaces(Bitboard piece) {$/;"	f	class:GameState
graph	MoveGenerator.h	/^		IntermediateGraph graph;$/;"	m	class:MoveGenerator
grasshoppers	GameState.h	/^	Bitboard grasshoppers;$/;"	m	class:GameState
hash	Bitboard.cpp	/^int Bitboard::hash() {$/;"	f	class:Bitboard
hash	GameState.h	/^struct std::hash<MoveInfo> {$/;"	s	class:std
hash	ProblemNode.cpp	/^int ProblemNodeContainer::hash(int boardIndex, unsigned long long piece) {$/;"	f	class:ProblemNodeContainer
heuristic	AlphaBeta.h	/^		Heuristic heuristic;$/;"	m	class:AlphaBeta
heuristicEvals	MonteCarloNode.h	/^		vector <double> heuristicEvals;$/;"	m	class:MonteCarloNode
heuristicFactor	constants.cpp	/^double heuristicFactor = .5;$/;"	v
heuristicScore	MonteCarloNode.h	/^		double heuristicScore;$/;"	m	class:MonteCarloNode
immobile	GameState.h	/^	Bitboard immobile;$/;"	m	class:GameState
initialize	Bitboard.cpp	/^void Bitboard::initialize(unordered_map < int, unsigned long long> predefinedBoards) {$/;"	f	class:Bitboard
initialize	Weight.cpp	/^void KillShotCountWeight::initialize(GameState* g) {$/;"	f	class:KillShotCountWeight
initialize	Weight.cpp	/^void PieceCountWeight::initialize(GameState * gameState){$/;"	f	class:PieceCountWeight
initialize	Weight.h	/^		virtual void initialize(GameState * g){$/;"	f	class:Weight
initializeTo	Bitboard.cpp	/^void Bitboard::initializeTo(Bitboard &other) {$/;"	f	class:Bitboard
initializeTo	MonteCarloTree.h	/^		void initializeTo(MonteCarloTree& MCT) {$/;"	f	class:MonteCarloTree
initializeTo	PieceGraph.h	/^		void initializeTo (const PieceGraph& other) {$/;"	f	class:PieceGraph
inlinePinWeight	Weight.h	/^		double inlinePinWeight = 1;$/;"	m	class:PinningPowerWeight
insert	PieceGraph.cpp	/^void PieceGraph::insert(Bitboard& newBitboard) {$/;"	f	class:PieceGraph
insert	PieceNode.cpp	/^void PieceNode::insert( list <PieceNode*> &newNeighbors, Bitboard &newBitboard) {$/;"	f	class:PieceNode
insert	ProblemNode.cpp	/^void ProblemNodeContainer::insert(Bitboard& problemNodes) {$/;"	f	class:ProblemNodeContainer
insertPiece	ProblemNode.cpp	/^void ProblemNodeContainer::insertPiece(Bitboard & piece) {$/;"	f	class:ProblemNodeContainer
intRand	MonteCarloTree.cpp	/^int intRand(const int & min, const int & max) {$/;"	f
internalBoardCache	Bitboard.h	/^	boost::container::flat_set<int> internalBoardCache;$/;"	m	class:Bitboard
internalBoards	Bitboard.h	/^	unsigned long long internalBoards[BITBOARD_SIZE];$/;"	m	class:Bitboard
intersectionWith	Bitboard.cpp	/^void Bitboard::intersectionWith( Bitboard &other) {$/;"	f	class:Bitboard
isGameOver	Arena.h	/^		bool isGameOver(){$/;"	f	class:Arena
ladybugStep	MoveGenerator.cpp	/^void MoveGenerator::ladybugStep(Bitboard& frontier,	$/;"	f	class:MoveGenerator
ladybugs	GameState.h	/^	Bitboard ladybugs;$/;"	m	class:GameState
load	Heuristic.cpp	/^void Heuristic::load(){$/;"	f	class:Heuristic
loadWeights	Heuristic.cpp	/^void Heuristic::loadWeights(string){$/;"	f	class:Heuristic
location	PieceNode.h	/^		unsigned long long location = 0;$/;"	m	class:PieceNode
locationHashTable	ProblemNode.h	/^		unordered_map <int, list<Bitboard>> locationHashTable;$/;"	m	class:ProblemNodeContainer
lowLink	PieceNode.h	/^		int lowLink;$/;"	m	class:PieceNode
lowerLeftGate	ProblemNode.cpp	/^int lowerLeftGate = (BITBOARD_ROWS - 1)*BITBOARD_COLS;$/;"	v
main	Test.cpp	/^int main() {$/;"	f
makeMove	Arena.cpp	/^void Arena::makeMove(MoveInfo move){$/;"	f	class:Arena
makeMove	Arena.cpp	/^void Arena::makeMove(string move){$/;"	f	class:Arena
makePsuedoRandomMove	GameState.cpp	/^bool GameState::makePsuedoRandomMove() {$/;"	f	class:GameState
makeTrueRandomMove	GameState.cpp	/^bool GameState::makeTrueRandomMove() {$/;"	f	class:GameState
maxAvgScore	MonteCarloNode.h	/^		double maxAvgScore = -1;$/;"	m	class:MonteCarloNode
maxChildScore	MonteCarloNode.h	/^		double maxChildScore;$/;"	m	class:MonteCarloNode
minChildScore	MonteCarloNode.h	/^		double minChildScore;$/;"	m	class:MonteCarloNode
minLearningFraction	MonteCarloTree.cpp	/^double minLearningFraction = .1;$/;"	v
minimax	AlphaBeta.cpp	/^double AlphaBeta::minimax(GameState& childGameState, int depth, bool maximizingPlayer, $/;"	f	class:AlphaBeta
minimaxTest	Test.cpp	/^void minimaxTest(int depth){$/;"	f
modulo	constants.cpp	/^unsigned modulo( int value, unsigned m) {$/;"	f
mosquitoes	GameState.h	/^	Bitboard mosquitoes;$/;"	m	class:GameState
moveApproximation	GameState.cpp	/^int GameState::moveApproximation(Bitboard piece, bool isPinned){$/;"	f	class:GameState
moveGenerator	GameState.h	/^	MoveGenerator moveGenerator;$/;"	m	class:GameState
moveHistory	AlphaBeta.h	/^		stack<MoveInfo> moveHistory;$/;"	m	class:AlphaBeta
moveHistory	Arena.h	/^		vector<MoveInfo> moveHistory;$/;"	m	class:Arena
moveHistoryNotation	Arena.h	/^		vector<string> moveHistoryNotation;$/;"	m	class:Arena
movePiece	GameState.cpp	/^MoveInfo GameState::movePiece(Bitboard& oldBitboard, Bitboard& newBitboard,$/;"	f	class:GameState
moves	MoveGenerator.h	/^		Bitboard moves;$/;"	m	class:MoveGenerator
movesCollection	GameState.h	13;"	d
multiSearch	MonteCarloTree.cpp	/^MoveInfo MonteCarloTree::multiSearch(GameState& initialGameState, int numThreads){$/;"	f	class:MonteCarloTree
multiplier	Weight.h	/^		double multiplier;$/;"	m	class:Weight
neighbors	PieceNode.h	/^		list <PieceNode*> neighbors;	$/;"	m	class:PieceNode
newPieceLocation	GameState.h	/^	Bitboard newPieceLocation;$/;"	m	struct:MoveInfo
nodeMap	MonteCarloTree.h	9;"	d
nodePtr	MonteCarloNode.h	7;"	d
nodes	PieceGraph.h	/^		unordered_map<int, boost::container::flat_set<int>> nodes;$/;"	m	class:IntermediateGraph
notIntersectionWith	Bitboard.cpp	/^void Bitboard::notIntersectionWith( Bitboard &other) {$/;"	f	class:Bitboard
numCores	constants.cpp	/^int numCores = 1;$/;"	v
numDirections	ProblemNode.cpp	/^int numDirections = 6;$/;"	v
numHashTable	PieceGraph.h	/^		vector<Bitboard> numHashTable;$/;"	m	class:IntermediateGraph
numVisited	MonteCarloNode.h	/^		int numVisited = 0;$/;"	m	class:MonteCarloNode
oldPieceLocation	GameState.h	/^	Bitboard oldPieceLocation;$/;"	m	struct:MoveInfo
operator ()	GameState.h	/^       std::size_t operator()(const MoveInfo& m)const {$/;"	f	struct:std::hash
operator =	GameState.cpp	/^void GameState::operator=( const GameState& other){$/;"	f	class:GameState
operator =	PieceGraph.h	/^		void operator=(const PieceGraph& other){$/;"	f	class:PieceGraph
operator ==	Bitboard.h	/^	bool operator == (const Bitboard& other) const {$/;"	f	class:Bitboard
operator ==	Bitboard.h	/^	bool operator ==(Bitboard &other) {$/;"	f	class:Bitboard
operator ==	GameState.h	/^	bool operator==(const MoveInfo& other) const {$/;"	f	struct:MoveInfo
operator ==	PieceNode.h	/^		bool operator==(PieceNode &other) {$/;"	f	class:PieceNode
operator []	Bitboard.h	/^	inline unsigned long long operator [](int index) {$/;"	f	class:Bitboard
oppositeDirection	constants.cpp	/^unordered_map<Direction, Direction> oppositeDirection = $/;"	v
overflowBitmask	Bitboard.cpp	/^unordered_map <Direction, unsigned long long> overflowBitmask =$/;"	v
overflowLocation	Bitboard.cpp	/^unordered_map <Direction, vector<int>> overflowLocation =$/;"	v
override	Weight.h	/^		double evaluate(MoveInfo) override;$/;"	m	class:KillShotCountWeight
override	Weight.h	/^		double evaluate(MoveInfo) override;$/;"	m	class:PieceCountWeight
override	Weight.h	/^		double evaluate(MoveInfo) override;$/;"	m	class:PinnedWeight
override	Weight.h	/^		double evaluate(MoveInfo) override;$/;"	m	class:PinningPowerWeight
override	Weight.h	/^		void initialize(GameState * g) override;$/;"	m	class:KillShotCountWeight
override	Weight.h	/^		void initialize(GameState*) override;$/;"	m	class:PieceCountWeight
parameters	Bitboard.cpp	/^unordered_map <Direction, vector<int>> parameters  = {$/;"	v
parent	MonteCarloNode.h	/^		nodePtr parent = nullptr;$/;"	m	class:MonteCarloNode
parent	PieceNode.h	/^		PieceNode * parent;$/;"	m	class:PieceNode
parentGameState	Weight.h	/^		GameState * parentGameState;$/;"	m	class:Weight
pass	Test.cpp	/^void Test::pass(bool testPassed, string message){$/;"	f	class:Test
perfTest	Test.cpp	/^void perfTest() {$/;"	f
perimeter	MoveGenerator.h	/^		Bitboard perimeter;$/;"	m	class:MoveGenerator
pieceCounts	Weight.h	/^		int pieceCounts[2];$/;"	m	class:PieceCountWeight
pieceGraph	GameState.h	/^	PieceGraph pieceGraph;$/;"	m	class:GameState
pieceMoves	GameState.h	/^	list < pair <Bitboard , Bitboard > > pieceMoves;$/;"	m	class:GameState
pieceName	GameState.h	/^	PieceName pieceName = PieceName::LENGTH;$/;"	m	struct:MoveInfo
pieceNum	Test.cpp	/^ unordered_map <string, int> pieceNum = {{"Q",0},$/;"	v
pieceOrders	Arena.h	/^		unordered_map< int, vector<tuple<PieceName, PieceColor, string>>> pieceOrders;$/;"	m	class:Arena
pieceSpawns	GameState.h	/^	Bitboard pieceSpawns;$/;"	m	class:GameState
pieceStacks	GameState.h	/^	unordered_map < int , deque < pair < PieceColor , PieceName > > > pieceStacks;$/;"	m	class:GameState
pieceStacks	MoveGenerator.h	/^		unordered_map < int, deque < pair < PieceColor , PieceName> > > * pieceStacks; $/;"	m	class:MoveGenerator
piecesExceptCurrent	MoveGenerator.h	/^		Bitboard piecesExceptCurrent;$/;"	m	class:MoveGenerator
pillbugs	GameState.h	/^	Bitboard pillbugs;$/;"	m	class:GameState
pinned	GameState.h	/^	Bitboard pinned;    $/;"	m	class:GameState
pinnedWatchPoints	Weight.h	/^		Bitboard pinnedWatchPoints;$/;"	m	class:KillShotCountWeight
playerOneCPU	Arena.h	/^		bool playerOneCPU = false;$/;"	m	class:Arena
playerTwoCPU	Arena.h	/^		bool playerTwoCPU = false;$/;"	m	class:Arena
playout	GameState.cpp	/^int GameState::playout(int limitMoves) {$/;"	f	class:GameState
playoutScore	MonteCarloNode.h	/^		double playoutScore = 0;$/;"	m	class:MonteCarloNode
possibleNames	GameState.h	/^	set <PieceName> possibleNames;$/;"	m	class:GameState
potentialProblemNodes	ProblemNode.cpp	/^Bitboard potentialProblemNodes[] = {$/;"	v
prevImmobile	GameState.h	/^	Bitboard prevImmobile;$/;"	m	struct:MoveInfo
print	Bitboard.cpp	/^void Bitboard::print() {$/;"	f	class:Bitboard
print	GameState.cpp	/^void GameState::print() {$/;"	f	class:GameState
print	PieceGraph.h	/^		void print() {$/;"	f	class:IntermediateGraph
print	PieceNode.cpp	/^void PieceNode::print() {$/;"	f	class:PieceNode
problemNodeContainer	GameState.h	/^	ProblemNodeContainer problemNodeContainer;$/;"	m	class:GameState
problemNodeExists	ProblemNode.cpp	/^bool ProblemNodeContainer::problemNodeExists(Bitboard& problemNode) {$/;"	f	class:ProblemNodeContainer
problemNodeHashes	ProblemNode.h	/^		unordered_set <int> problemNodeHashes;$/;"	m	class:ProblemNodeContainer
problemNodes	MoveGenerator.h	/^		ProblemNodeContainer *problemNodes;$/;"	m	class:MoveGenerator
problemNodesEnabled	MoveGenerator.h	/^		bool problemNodesEnabled = false;$/;"	m	class:MoveGenerator
proven	MonteCarloNode.h	/^		bool proven = false;$/;"	m	class:MonteCarloNode
pruneCache	Bitboard.cpp	/^void Bitboard::pruneCache(){$/;"	f	class:Bitboard
queenCount	Weight.h	/^		int queenCount;$/;"	m	class:KillShotCountWeight
queens	GameState.h	/^	Bitboard queens;$/;"	m	class:GameState
randomMovePiece	GameState.cpp	/^void GameState::randomMovePiece(Bitboard& initialPiece,$/;"	f	class:GameState
randomSpawnPiece	GameState.cpp	/^void GameState::randomSpawnPiece(Bitboard& spawnLocations) {$/;"	f	class:GameState
randomSwapPiece	GameState.cpp	/^void GameState::randomSwapPiece(Bitboard swappable, Bitboard empty) {$/;"	f	class:GameState
rd	Bitboard.cpp	/^std::random_device rd;     \/\/Get a random seed from the OS entropy device, or whatever$/;"	v
recalculate	Weight.cpp	/^vector<int> KillShotCountWeight::recalculate() {$/;"	f	class:KillShotCountWeight
remove	PieceGraph.cpp	/^void PieceGraph::remove(Bitboard& oldBitboard) {$/;"	f	class:PieceGraph
remove	PieceGraph.h	/^		void remove(Bitboard removingNodes) {$/;"	f	class:IntermediateGraph
remove	PieceNode.cpp	/^void PieceNode::remove() {$/;"	f	class:PieceNode
remove	ProblemNode.cpp	/^void ProblemNodeContainer::remove(Bitboard & problemNodes) {$/;"	f	class:ProblemNodeContainer
removePiece	ProblemNode.cpp	/^void ProblemNodeContainer::removePiece( Bitboard & piece) {$/;"	f	class:ProblemNodeContainer
replayMove	GameState.cpp	/^void GameState::replayMove(MoveInfo moveInfo) {$/;"	f	class:GameState
reposition	PieceGraph.cpp	/^void PieceGraph::reposition(Bitboard& oldBitboard, Bitboard& newBitboard) {$/;"	f	class:PieceGraph
reposition	PieceNode.cpp	/^void PieceNode::reposition(list <PieceNode*> &newNeighbors, Bitboard &newBitboard){$/;"	f	class:PieceNode
root	PieceGraph.h	/^		Bitboard root;$/;"	m	class:IntermediateGraph
rootGameState	AlphaBeta.h	/^		GameState rootGameState;$/;"	m	class:AlphaBeta
rotateClockWise	constants.cpp	/^Direction rotateClockWise(Direction dir) {$/;"	f
rotateCounterClockWise	constants.cpp	/^Direction rotateCounterClockWise(Direction dir) {$/;"	f
save	Heuristic.cpp	/^void Heuristic::save(){$/;"	f	class:Heuristic
saveWeights	Heuristic.cpp	/^void Heuristic::saveWeights(string){$/;"	f	class:Heuristic
score	Heuristic.h	/^		double score;$/;"	m	class:Heuristic
scores	Weight.h	/^		double scores[2];$/;"	m	class:KillShotCountWeight
search	AlphaBeta.cpp	/^MoveInfo AlphaBeta::search(int depth){$/;"	f	class:AlphaBeta
search	MonteCarloTree.cpp	/^MoveInfo MonteCarloTree::search(nodePtr root, GameState initialGameState, int numTrials){$/;"	f	class:MonteCarloTree
selectBestLeaf	MonteCarloTree.cpp	/^queue <MoveInfo> MonteCarloTree::selectBestLeaf(nodePtr& parent){$/;"	f	class:MonteCarloTree
selectionFunction	MonteCarloTree.cpp	/^double MonteCarloTree::selectionFunction(MoveInfo m, nodePtr currentParent) {$/;"	f	class:MonteCarloTree
setBoard	Bitboard.cpp	/^void Bitboard::setBoard(int boardIndex, unsigned long long board) {$/;"	f	class:Bitboard
setGameState	Heuristic.cpp	/^void Heuristic::setGameState(GameState parentGameState) {$/;"	f	class:Heuristic
setGeneratingName	MoveGenerator.cpp	/^void MoveGenerator::setGeneratingName(PieceName * pieceNameIn) {$/;"	f	class:MoveGenerator
setGeneratingPieceBoard	MoveGenerator.cpp	/^void MoveGenerator::setGeneratingPieceBoard(Bitboard * b) {$/;"	f	class:MoveGenerator
setPieceStacks	MoveGenerator.cpp	/^void MoveGenerator::setPieceStacks(unordered_map <int , deque <pair < PieceColor , PieceName >>> * in) {$/;"	f	class:MoveGenerator
setPlayer	Arena.cpp	/^void Arena::setPlayer(int playerNum, MonteCarloTree& searchAlgo) {$/;"	f	class:Arena
setUpperLevelPieces	MoveGenerator.cpp	/^void MoveGenerator::setUpperLevelPieces(Bitboard * in) {$/;"	f	class:MoveGenerator
shiftDirection	Bitboard.cpp	/^void Bitboard::shiftDirection(Direction dir) {$/;"	f	class:Bitboard
shiftDirection	Bitboard.cpp	/^void Bitboard::shiftDirection(Direction dir, int numTimes){$/;"	f	class:Bitboard
shiftOrthogonalDirection	Bitboard.cpp	/^void Bitboard::shiftOrthogonalDirection(Direction dir, int numTimes){$/;"	f	class:Bitboard
silent	Test.cpp	/^bool Test::silent = false;$/;"	m	class:Test	file:
silent	Test.h	/^		static bool silent;$/;"	m	class:Test
simulate	MonteCarloTree.cpp	/^double MonteCarloTree::simulate(GameState gameState){$/;"	f	class:MonteCarloTree
singlePieces	Arena.cpp	/^set<PieceName> singlePieces = {MOSQUITO, QUEEN, LADYBUG, PILLBUG};$/;"	v
slowGetPerimeter	Bitboard.cpp	/^Bitboard Bitboard::slowGetPerimeter(){$/;"	f	class:Bitboard
spawnNames	GameState.h	/^	set <PieceName> spawnNames;$/;"	m	class:GameState
spiders	GameState.h	/^	Bitboard spiders;$/;"	m	class:GameState
split	Bitboard.cpp	/^unordered_map< int, vector < unsigned long long >> Bitboard::split(){$/;"	f	class:Bitboard
splitIntoBitboards	Bitboard.cpp	/^list <Bitboard> Bitboard::splitIntoBitboards() {$/;"	f	class:Bitboard
splitIntoConnectedComponents	Bitboard.cpp	/^vector <Bitboard> Bitboard::splitIntoConnectedComponents(){$/;"	f	class:Bitboard
swappableEmpty	GameState.h	/^	vector <pair<Bitboard, Bitboard>> swappableEmpty;$/;"	m	class:GameState
testAntMoves	Test.cpp	/^void Test::MoveGeneratorTest::testAntMoves() {$/;"	f	class:Test::MoveGeneratorTest
testArenaNotation	Test.cpp	/^void Test::ArenaTest::testArenaNotation() {$/;"	f	class:Test::ArenaTest
testBattle	Test.cpp	/^void Test::ArenaTest::testBattle() {$/;"	f	class:Test::ArenaTest
testBeetleMoves	Test.cpp	/^void Test::MoveGeneratorTest::testBeetleMoves() {$/;"	f	class:Test::MoveGeneratorTest
testContainsAny	Test.cpp	/^void Test::BitboardTest::testContainsAny() {$/;"	f	class:Test::BitboardTest
testFastPerimeter	Test.cpp	/^void Test::BitboardTest::testFastPerimeter(){$/;"	f	class:Test::BitboardTest
testFastSpawnPiece	Test.cpp	/^void Test::GameStateTest::testFastSpawnPiece(){$/;"	f	class:Test::GameStateTest
testFindAllPinnedPieces	Test.cpp	/^void Test::PieceGraphTest::testFindAllPinnedPieces(){$/;"	f	class:Test::PieceGraphTest
testFindAllProblemNodes	Test.cpp	/^void Test::ProblemNodeContainerTest::testFindAllProblemNodes(){$/;"	f	class:Test::ProblemNodeContainerTest
testFloodFill	Test.cpp	/^void Test::BitboardTest::testFloodFill() {$/;"	f	class:Test::BitboardTest
testFloodFillStep	Test.cpp	/^void Test::BitboardTest::testFloodFillStep() {$/;"	f	class:Test::BitboardTest
testGrasshopperMoves	Test.cpp	/^void Test::MoveGeneratorTest::testGrasshopperMoves() {$/;"	f	class:Test::MoveGeneratorTest
testIntersectionWith	Test.cpp	/^void Test::BitboardTest::testIntersectionWith() {$/;"	f	class:Test::BitboardTest
testLadybugMoves	Test.cpp	/^void Test::MoveGeneratorTest::testLadybugMoves() {$/;"	f	class:Test::MoveGeneratorTest
testMovePiece	Test.cpp	/^void Test::GameStateTest::testMovePiece(){$/;"	f	class:Test::GameStateTest
testPillbugMoves	Test.cpp	/^void Test::MoveGeneratorTest::testPillbugMoves() {$/;"	f	class:Test::MoveGeneratorTest
testPlayout	Test.cpp	/^void Test::GameStateTest::testPlayout() {$/;"	f	class:Test::GameStateTest
testPsuedoRandom	Test.cpp	/^void Test::GameStateTest::testPsuedoRandom() {$/;"	f	class:Test::GameStateTest
testQueenMoves	Test.cpp	/^void Test::MoveGeneratorTest::testQueenMoves() {$/;"	f	class:Test::MoveGeneratorTest
testRandomSearch	Test.cpp	/^void Test::MonteCarloTest::testRandomSearch(){$/;"	f	class:Test::MonteCarloTest
testRemovePiece	Test.cpp	/^void Test::ProblemNodeContainerTest::testRemovePiece(bool noMessage){$/;"	f	class:Test::ProblemNodeContainerTest
testShiftDirection	Test.cpp	/^void Test::BitboardTest::testShiftDirection(){$/;"	f	class:Test::BitboardTest
testSpiderMoves	Test.cpp	/^void Test::MoveGeneratorTest::testSpiderMoves() {$/;"	f	class:Test::MoveGeneratorTest
testSplit	Test.cpp	/^void Test::BitboardTest::testSplit() {$/;"	f	class:Test::BitboardTest
testSplitIntoConnectedComponents	Test.cpp	/^void Test::BitboardTest::testSplitIntoConnectedComponents() {$/;"	f	class:Test::BitboardTest
testUnionWith	Test.cpp	/^void Test::BitboardTest::testUnionWith() {$/;"	f	class:Test::BitboardTest
testXorWith	Test.cpp	/^void Test::BitboardTest::testXorWith() {$/;"	f	class:Test::BitboardTest
toString	GameState.h	/^	const string toString(string prefix) const {$/;"	f	struct:MoveInfo
toString	MonteCarloNode.h	/^		string toString(int depth, string prefix) {$/;"	f	class:MonteCarloNode
train	Heuristic.cpp	/^void Heuristic::train(vector<double> corrections){$/;"	f	class:Heuristic
train	MonteCarloNode.h	/^		vector <double> train(double maxExpectedScore , double minExpectedScore,$/;"	f	class:MonteCarloNode
train	MonteCarloTree.cpp	/^void MonteCarloTree::train(nodePtr node, set<nodePtr>& visited, vector<double>& corrections){$/;"	f	class:MonteCarloTree
trainingMode	MonteCarloTree.h	/^		bool trainingMode = false;$/;"	m	class:MonteCarloTree
turnColor	GameState.h	/^	PieceColor turnColor;$/;"	m	class:GameState
turnCounter	GameState.h	/^	int turnCounter = 0;$/;"	m	class:GameState
undo	Arena.cpp	/^void Arena::undo(MoveInfo move){$/;"	f	class:Arena
undo	Arena.cpp	/^void Arena::undo(string move){$/;"	f	class:Arena
undoMove	GameState.cpp	/^void GameState::undoMove(MoveInfo moveInfo) {$/;"	f	class:GameState
unionWith	Bitboard.cpp	/^void Bitboard::unionWith( Bitboard &other){$/;"	f	class:Bitboard
unionWith	Bitboard.cpp	/^void Bitboard::unionWith(int boardIndex, unsigned long long board) {$/;"	f	class:Bitboard
unpinnedWatchPoints	Weight.h	/^		Bitboard unpinnedWatchPoints;$/;"	m	class:KillShotCountWeight
unusedPieces	GameState.h	/^	vector <unordered_map <PieceName, int>> unusedPieces;$/;"	m	class:GameState
updateVisible	ProblemNode.cpp	/^void ProblemNodeContainer::updateVisible(Bitboard& locations) {$/;"	f	class:ProblemNodeContainer
upperLevelPieces	GameState.h	/^	Bitboard upperLevelPieces;$/;"	m	class:GameState
upperLevelPieces	MoveGenerator.h	/^		Bitboard * upperLevelPieces;$/;"	m	class:MoveGenerator
visibleProblemNodes	ProblemNode.h	/^		Bitboard visibleProblemNodes;$/;"	m	class:ProblemNodeContainer
visitedNum	PieceNode.h	/^		int visitedNum;$/;"	m	class:PieceNode
watchPoints	Weight.h	/^		Bitboard watchPoints;$/;"	m	class:KillShotCountWeight
weights	Heuristic.h	/^		vector <Weight *> weights;$/;"	m	class:Heuristic
westernDirection	Arena.cpp	/^set<Direction> westernDirection = {NW, SW, W};$/;"	v
whitePieces	GameState.h	/^	Bitboard whitePieces;$/;"	m	class:GameState
xorWith	Bitboard.cpp	/^void Bitboard::xorWith( Bitboard &other) {$/;"	f	class:Bitboard
~GameState	GameState.h	/^	~GameState() { destroy();}$/;"	f	class:GameState
~MoveGraph	PieceGraph.h	/^		~MoveGraph(){destroy();};$/;"	f	class:MoveGraph
~PieceGraph	PieceGraph.h	/^		~PieceGraph() { destroy();}$/;"	f	class:PieceGraph
